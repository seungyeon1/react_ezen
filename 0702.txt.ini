인스타그램, 에어비앤비..리액트로 만듬 

리액트 는 라이브러리 (꼇다,켰다), 컴포넌트 , 페북에서 만듬  // 뷰는 프레임워크 (자체 틀), 개인이..만듬
확장성 가능
자바스크립트 -> 리액트 -> 리액트네이티브 까지 가능 

기존 MVC 아키텍쳐의 단점을 보안
오직 뷰만 관리한다.!

초기렌더링 / 리렌더링 
리액트 : 수정된곳을 비교해서 바로 삭제 하고 바로 삽입 한다. 
기존 MVC 아키텍쳐  : 수정할곳을 찾아서 수정한다

리액트는 돔을 -> 버츄얼돔으로 사용한다.  

API 는 요청하고 주고 성호작용이 되어 // ex) 콘솔

돔 단점 : 동적 구조가 아님 / 정적 이다 
동적 구조 할려면 자바스크립트 사용 
웹브라우저에서 돔이 움직이면 여기에 대한 시간 소비가 큼.. 돔자체가 느린게 아님 

리액트에서 데이터가 변하면 웹브라우저에서 실제 DOM을 업데이트 할 때 3가지 절차가 있다.
1. 데이터를 업데이트 하면 전체 UI를 Virtual Dom에 리렌더링 한다.
2. 이전 Virtual Dom에 있던 내용과 현재 내용을 비교한다. (삭제후 삽입)
3. 바뀐 부분만 실제 Dom에 적용한다. 
초기렌더링을 복사한상태에서 리렌더링 비교 하면 된다. 다시 읽는 구조가 아님 

리액트 단점은 회사마다 플젝 다름
즉 규모가 작은거 필요가없다.

cli환경에서 이루어지는데 
cli환경 -> node 모듈이 무조건 깔아진다. 너무 무거우니까 작은규모에서 오히려 불필요 
상태관리, 최적화 관리

상태관리 : 클릭수 조회 

리덕트 까지 최종 목표 
자바스크립트에서 리덕스방법
리액트안에서 리덕스 방법


node js : 패키지를 쉽게 사용하기위해// 크롬 자바스크립트 엔진 런타임 // 웹브라우저에서 아닌곳에서 자바스크립트 사용하기 위해 // 주요 도구가 다 있다. 
패키지 관리 해주는 npm 
npm(노드 버전 맞춰야함..) 대신해서 사용가능한게 yarn (버전 상관없음) : (캐쉬 시스템, 부가서비스 기능 제공 npm 보다 요즘 좋다)


크로스브라우저들을 합쳤음 (각각 다르게 자바스크립트 문법이라 우리 이제 통합하자해서 es6 표준 했고.)
babel 사용해서 일반 자바스크립 코드를 변환해줘서 크로스브라우저에서 다 보여지도록 해준다. 


es5 이전 
var사용 하게 되면
this가 윈도우에 접하는 큰 단점이있어서
es6 이후에는 막았다.
let, const !

---jsx문법 --- 
index.js :  <React.StrictMode>  : 예전문법 사용 못하도록 16이상만 사용가능
but 2번씩 읽어 준다. 그래서 성능상 이슈 가 있어서 배포때 뺀다.

if 대신 조건부연산자로 사용한다 
0 : false
1: true

0은 false로 인식되니까 0으로 나온다. 
숫자값 0으로 처리하기위해서 따로 조건처리 해줘야한다. 

https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/undefined
-> mdn 공식 사이트 

리액트에서 undefined는 에러다. (기본 js랑 다름)
리액트 컴포넌트에서는 함수에서 undefined 만 반환하여 랜더링하면 안된다.
만약 undefined 꼭 필요한 상황이라면 ||(false인거니?) 연산자 사용하여 값을 지정해 오류를 방지할 수 있다. 
&&(참인거니?)

return <div></div> : jsx문법이다.. fragment, <>, <div> 3가지가 돔 구조 리액트 !


대응방법 
(o)
function myFunc() {
  const name = undefined;
  return name || "값이 undefined입니다 대응방법 "; --> o 
}
(o) jsx문법 활용 
function myFunc() {
  const name = undefined;
  return <div>{ name || "값이 undefined입니다 대응방법2" } </div> ; --> o 
}
(x)
function myFunc() {
  const name = undefined;
  return name; --> x 
}

.prettierrc 
https://prettier.io/docs/en/options.html


주석 길때는 /* */

class : 연관이 있는 집합을 연결해주는 함수의 집합

new {인스턴트} .. 

prototype ES5 라서 class로 es6로 통합 되었당. 

함수형 컴포넌트 단점은 state와 라이프사이클 api 사용이 불가능하다는 점인데 
이 단점은 리액트 v16.8 이후부터 Hooks 라는 기능이 도입이 되면서 해결되었다.
클래스형과 비슷하게 구현할 수 있다. 
리액트 공식 메뉴얼에서는 컴포넌트를 새로 작성 할 때는 함수 컴포넌트와 Hooks을 사용하도록 
권장 하고 있다. 그렇다고 클래스형 컴포넌트 사라진건 아니고 , 클래스형 컴포넌트 기능은
알아두는것을 권장 한다. 

일반함수 vs 화살표 함수 
this의 차이다. 
일반함수는 자신이 종속된 객체를 this로 가리킨다. 블럭으로 가리킨다.
화살표함수는 자신이 종속된 'new 인스턴스'로 가리킨다. 

//일반 함수의 this 
function BlackDog(){
  this.name = '흰둥이';
  return {
    name : '검둥이',
    bark : function(){
      console.log(this.name + ' : 멍멍');
    }
  }
}

const blackDog = new BlackDog();
blackDog.bark(); ---> 검둥이 : 멍멍 

//화살표 함수의 this 
function BlackDog(){
  this.name = '흰둥이';
  return {
    name : '검둥이',
    bark: ()=> {
      console.log(this.name + ' : 멍멍');
    }
  }
}

const blackDog = new BlackDog();
blackDog.bark(); ---> 흰둥이 : 멍멍 


#props(properties) 컴포넌트 속성을 설정할 때 사용하는 요소 
부모에 있는 prpos를 전달 받는거다.  