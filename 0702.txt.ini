인스타그램, 에어비앤비..리액트로 만듬 

리액트 는 라이브러리 (꼇다,켰다), 컴포넌트 , 페북에서 만듬  // 
뷰는 프레임워크 (자체 틀) - 개인이..만듬
리액트는 확장성 가능
자바스크립트 -> 리액트 -> 리액트네이티브 까지 가능 

기존 MVC 아키텍쳐의 단점을 보안
오직 뷰만 관리한다.!

초기렌더링 / 리렌더링 
리액트 : 수정된곳을 비교해서 바로 삭제 하고 바로 삽입 한다. (업데이트가 아니다)
기존 MVC 아키텍쳐  : 수정할곳을 찾아서 수정한다

리액트는 돔을 -> 버츄얼돔으로 사용한다.  

API 는 요청하고 주고 성호작용이 되어 // ex) 콘솔

돔 단점 : 동적 구조가 아님 / 정적 이다 
동적 구조 할려면 자바스크립트 사용 
웹브라우저에서 돔이 움직이면 여기에 대한 시간 소비가 큼.. 돔자체가 느린게 아님 

리액트에서 데이터가 변하면 웹브라우저에서 실제 DOM을 업데이트 할 때 3가지 절차가 있다.
1. 데이터를 업데이트 하면 전체 UI를 Virtual Dom에 리렌더링 한다.
2. 이전 Virtual Dom에 있던 내용과 현재 내용을 비교한다. (삭제후 삽입)
3. 바뀐 부분만 실제 Dom에 적용한다. 
초기렌더링을 복사한상태에서 리렌더링 비교 하면 된다. 다시 읽는 구조가 아님 

리액트 단점은 회사마다 플젝 다름
즉 규모가 작은거 필요가없다.

cli환경에서 이루어지는데 
cli환경 -> node 모듈이 무조건 깔아진다. 너무 무거우니까 작은규모에서 오히려 불필요 
상태관리, 최적화 관리

상태관리 : 클릭수 조회 

리덕트 까지 최종 목표 
자바스크립트에서 리덕스방법
리액트안에서 리덕스 방법


node js : 패키지를 쉽게 사용하기위해// 크롬 자바스크립트 엔진 런타임 // 웹브라우저에서 아닌곳에서 자바스크립트 사용하기 위해 // 주요 도구가 다 있다. 
패키지 관리 해주는 npm 
npm(노드 버전 맞춰야함..) 대신해서 사용가능한게 yarn (버전 상관없음) : (캐쉬 시스템, 부가서비스 기능 제공 npm 보다 요즘 좋다)


크로스브라우저들을 합쳤음 (각각 다르게 자바스크립트 문법이라 우리 이제 통합하자해서 es6 표준 했고.)
babel 사용해서 일반 자바스크립 코드를 변환해줘서 크로스브라우저에서 다 보여지도록 해준다. 


es5 이전 
var사용 하게 되면
this가 윈도우에 접하는 큰 단점이있어서
es6 이후에는 막았다.
let, const !

---jsx문법 --- 
index.js :  <React.StrictMode>  : 예전문법 사용 못하도록 16이상만 사용가능
but 2번씩 읽어 준다. 그래서 성능상 이슈 가 있어서 배포때 뺀다.

if 대신 조건부연산자로 사용한다 
0 : false
1: true

0은 false로 인식되니까 0으로 나온다. 
숫자값 0으로 처리하기위해서 따로 조건처리 해줘야한다. 

https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/undefined
-> mdn 공식 사이트 

리액트에서 undefined는 에러다. (기본 js랑 다름)
리액트 컴포넌트에서는 함수에서 undefined 만 반환하여 랜더링하면 안된다.
만약 undefined 꼭 필요한 상황이라면 ||(false인거니?) 연산자 사용하여 값을 지정해 오류를 방지할 수 있다. 
&&(참인거니?)

return <div></div> : jsx문법이다.. fragment, <>, <div> 3가지가 돔 구조 리액트 !


대응방법 
(o)
function myFunc() {
  const name = undefined;
  return name || "값이 undefined입니다 대응방법 "; --> o 
}
(o) jsx문법 활용 
function myFunc() {
  const name = undefined;
  return <div>{ name || "값이 undefined입니다 대응방법2" } </div> ; --> o 
}
(x)
function myFunc() {
  const name = undefined;
  return name; --> x 
}

.prettierrc 
https://prettier.io/docs/en/options.html


주석 길때는 /* */

class : 연관이 있는 집합을 연결해주는 함수의 집합

new {인스턴트} .. 
인스턴트 객체 : 복사한 객체..

prototype ES5 라서 class로 es6로 통합 되었당. 

리액트 v16.8 이후 함수형 컴포넌트 권장 !!
함수형 컴포넌트 단점은 state와 라이프사이클 api 사용이 불가능하다는 점인데 
이 단점은 리액트 v16.8 이후부터 Hooks 라는 기능이 도입이 되면서 해결되었다.
클래스형과 비슷하게 구현할 수 있다. 
리액트 공식 메뉴얼에서는 컴포넌트를 새로 작성 할 때는 함수 컴포넌트와 Hooks을 사용하도록 
권장 하고 있다. 그렇다고 클래스형 컴포넌트 사라진건 아니고 , 클래스형 컴포넌트 기능은
알아두는것을 권장 한다. 

일반함수 vs 화살표 함수 
this의 차이다. 
일반함수는 자신이 종속된 객체를 this로 가리킨다. 블럭으로 가리킨다.
화살표함수는 자신이 종속된 'new 인스턴스'로 가리킨다. 


//일반 함수의 this 
function BlackDog(){
  this.name = '흰둥이';
  return {
    name : '검둥이',
    bark : function(){
      console.log(this.name + ' : 멍멍');
    }
  }
}

const blackDog = new BlackDog();
blackDog.bark(); ---> 검둥이 : 멍멍 

//화살표 함수의 this 
function BlackDog(){
  this.name = '흰둥이';
  return {
    name : '검둥이',
    bark: ()=> {
      console.log(this.name + ' : 멍멍');
    }
  }
}

const blackDog = new BlackDog();
blackDog.bark(); ---> 흰둥이 : 멍멍 


#props(properties) 컴포넌트 속성을 설정할 때 사용하는 요소 
부모에 있는 prpos를 전달 받는거다.  

----------------------------------------------------07/09
gitbash = mac 호환 땜에 설치 
javascript 확장성 큰 이유는 node때문이기도 하다.

node : 태그 를 노드라고 한다. 그래서 텍스트토드 자식 노드 알아서 인식 한다. 

MDN 에서 찾아보자! 
https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment
destructuring : 구조 분해 할당
자바스크립트에서 자주 사용하는 문법 
var x = [1, 2, 3, 4, 5];
var [y, z] = x;
console.log(y); // 1
console.log(z); // 2

= 대입 / == 같다

자바스크립트 유연하지만 단점은 제약이 없다. 장점이자 단점
그래서 타입스크립트가 나왔다 


Class형태에서 proptypes 설정이 2가지 방법이 있다. 외부, 내부 
함수형은 proptypes 외부 설정만 있다.

유효성 검사 할때는 제약걸어야함 

state: 리액트에서 컴포넌트 내부에서 바뀔 수 있는 값. 변화를 주겠다. 
-> 변화가 이루어질 변수선언 키워드 . 
-> 변화가 이루어질려면 동작이 필요함 즉 함수가 필요하다. setState() 사용 

class state : state
function state : useStatea 라는 함수를 통해 사용한다. 

[[Prototype]] :  es6에서 클래스다 !

this.setState({ number: number + 1 })  ---> 초깃값에서 실행 
이전값 담고 실행하고싶을때 함수  
this.setState((prevState, props) => {
  number : prevState.number + 1
})
prevState : 기존 상태
props: 현재 지니고 있는 props를 가리킨다. 

callback 함수 : 함수에서 {}은 오브젝트말고 실행한다는 뜻, {}, ()=> 같이 쓴다면
()=>은 콜백 함수 라고 한다. 
함수 실행후 그 이후에 실행내용을 더 하는거다. 


// 구조화 
const array = [1,2];
const one = array[0];
const two = array[1];

//비구조화로 변경 후 *리액트에서 자주 사용한다 
const array = [1,2];
const [one, two] = array;


***리액트에서 함수 컴포넌트 hooks
hooks 
--> 클래스형에서 아주 잘 만들어놓은 함수를 함수 컴포넌트에서 hooks이라고 한다.
--> 배열에 비구조화 할당문으로 되어있다. 
--> 기본이 배열이다.
state 값을 바꾸어야 할 때는 setState 혹은 useStatea를 통해 전달받은 set 함수를 사용해야 한다. 

ex) state 사용법중 다음 코드는 잘못된 코드이다.
//클래스형 컴포넌트에서 (X)
공통 ) 기존에서 직접적으로 변경이 안됨 
this.state.number = this.state.number + 1;
this.state.array = this.array.push(2); //push 안됨
-> this.state.array = this.array.concat(2); // concat으로 사용 (ㅇ)
--> const id = [
  {id:1, value: true},
  {id:2, value: true},
  {id:3, value: false},
];
--> let idRest = id.concat({id:4, value : true});

-> const object = {a:1, b:2, c:3}; // (ㅇ)
--> const nextObj = {...object, b:4};  (ㅇ)
rest 연산자 라고도 불림 [...argumnet] : 복사해서 새로운 객체로 만듦 : https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Functions/arguments

this.state.object.value = 5; //직접적으로 지정 안됨 

//함수형 컴포넌트에서 (x)
const [object, setObject] = useStatea({a:1, b:2});
object.b = 3


===== 리액트 구조 특징 =====
(불변성) 이뮤터블 : 처음에 생선된 값은 변경되면 안된다는 규칙
-> 기존 있는걸 냅두고 , 새롭게 만든다. 그래서 변화감지가 있을때 
업데이트 하는게 아니라 삭제후 삽입이다. 

//생성, 수정, 삭제, 
const id = [
  {id:1, value: true},
  {id:2, value: true},
  {id:3, value: false},
];
//4를 추가
let idRest = id.concat({id:4, value : true});
//filter한다 (delete도 됨)
let idRest1 = idRest.filter(item => item.id !== 3);
//map 
let idRest2 = idRest1.map(item => (item.id === 1 ? {...item, value:false}: item));

#이벤트 핸들링
## 이벤트를 사용할때 주의사항
1. 이벤트 이름은 카멜 표기법으로 작성한다. 
2. 이벤트를 실행할 자바스크립트 코드를 전달하는 것이 아니라 함수형태의 값을 전달한다.
3. dom 요소에만 이벤트를 설정할 수 있다.
-> 우리가 직접 만든 컴포넌트에 이벤트를 자체적으로 설정할 수 없다. 
ex) <MyComopnent onClick ={doing}> 함수를 실행하는 것이 아니라.  그냥 이름이 onClick props 로 인식 되기때문이다. 
그러하여 <MyComopnent> 컴포넌트 안에 div즉 Dom 이벤트로 설정 해서 사용한다. 

##SyntheticBaseEvent : 값을 반환하고 초기화한다. 
즉 a를 한번 더 썻네가 아니라 초기화 후 aa 이네 
이렇게 !!! 생각 !!! 


#key [] 활용법 : 자바스크립트에서 있는 / 배열 아님 키값
const name = 'keyValue';
const object = {
  #key [] 감싸면 그 안에 레퍼런스가 가리키는 실제 값이 key값으로 사용된다. 
  [name]: 'value' // 
};
console.log(name) // 'keyValue' 

----------------------------------------------------07/16
ex) onKeyPress 함수 ===> onKeyUp
deprecated: (ㄷ프리케이트) 권장하지않는다 라는 뜻 / 실행은되지만 쓰지말라는 경고이다.
deprecated 문법이 보이면 찾아서 다른걸로 대체한다. 

excelh@naver.com => 강의쌤 이메일 

useState 성능적으로 안좋아서 훅으로 자주 사용한다
5개미만일때 useState 사용하는 정도 

ref(래퍼런스 약어 참조): 선택자 바로 선택하겠금 해당 이름을 짓는다.   
id값 대신 사용하고, id는 전역이며 ref는 컴포넌트 내부 (지역변수)에서만 작동하기 때문에  
id 사용하는것보다 보안이 좋기때문에 
리액트에서는 id값보다 ref 많이 사용한다. 
<div ref=""></div>
 
#dom을 꼭 사용해야 하는 상황
1. 특정 엘리먼트에 (input) 포커스 추가
2. 스크롤 박스 조작하기 

## ref를 사용하는 방법 두 가지
1. 콜백함수를 통한 ref 설정 (콜백함수 함수안에 함수를 가지고 있는 객체 함수안 함수안 함수 )
<input ref={{내마음대로이름} => {this.내마음대로이름22=내마음대로이름}} /> // 'this.aaa = input'
ref={(refa) => (this.inputRef = refa)}
this.inputRef.focus(); 

2. createRef : 리액트16.3 이후부터 도입 
REF를 설정해준 dom에 접근하려면 this.input.current를 조회 하자. 
콜백함수와 다른점 : 뒷부분에 .current를 넣어 줘야한 다는 점 
this.inputRef.current.focus(); 

# 리액트에서 컴포넌트에도 ref를 달 수 있다. 이 방법은 주로 컴포넌트 내부에 있는 dom을 컴포넌트 외부에서 사용할때 쓴다.
# App_2.js 참고 
<Component ref={(ref) => {this.Component = ref}} />
이렇게 하면 Component에 내부의 메서드 및 멤버 변수에도 접근 할 수 있다. 
Component.input 엘리먼트접근가능
Component.handleClick 함수로 접근가능

## scroll: 안보이는 영역
-scrollTop : 세로 스크롤바 위치 (0-350) //650-300
-scrollHeight : 스크롤이 있는 박스 안의 div 높이 (650)
-clientHeight : 스크롤이 있는 박스의 높이 (300)

## map : key 무조건 있어야한다. index가 key가 아니다!! 중요!  그래서 index값을 키값으로 하면안된다. 
https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/map 
const numbers = [1,2,3,4,5,6,7];
const processed = numbers.map(function(num){
  return num + num;
});
const processed = numbers.map(num => num + num);
##index값을 키값으로 하면안된다. 
(X) : const nameList = names.map((name, idx) => <li key={idx}>{name}</li>)

##삭제 filter 
const nextNames = names.filter((name) => name.id !== id); //(5)번 id가 (5)번 id 빼고 나와라

##컴포넌트 반복 
유동적인 배열을 렌더링할 때는 고유한 key값을 설정해야 한다. 
배열을 변형할 때 배열에 직접 접근하여 수정하는게 아니라 
concat, filter 등의 배열 내장 함수를 사용 하여 새로운 배열을 만든 후 
새로운 상태로 설정해줘야 한다는 점 
<li key={name.id} onDoubleClick={() => onRemove(name.id)}>
  {name.text}
</li>

##hooks : 16.8 이후에 도입 