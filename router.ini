--------------------------------------------------------08/06

SPA 싱글페이지에플리케이션
한번만 불러오고 필요한부분만 바뀐다. 서버에서 불러오지않고, 사용자브라우저에서 맡긴다. 
리액트 라우터 : 브라우저 api 사용 주소창에 따라 내용을 보이며 (사실은 한페이지)

$yarn add react-router-dom

import { BrowserRouter } from "react-router-dom";
index.js 
  <BrowserRouter>
    <App />
  </BrowserRouter>

사용자의 브라우저 주소 경로에 따라 우리가 원하는 컴포넌트를 보여주려면 Route 라는
컴포넌트를 통해 라우트 설정을 해줘야 한다.
<Routes>
    <Route path ="주소규칙" element = {보여 줄 컴포넌트 JSX} />
</Routes>

Link 컴포넌트를 사용하면 페이지를 새로 불러오는것을 막고 History API를 통해 브라우저 주소의
경로만 바꾸는 기능이 내장되어 있다.
<Link to ="경로">링크 이름</Link>

'url 파라미터' : /profile/mypage
-> 주소의 경로에 유도적인 값을 넣는 형태 
주로 ID 또는 이름을 사용하여 특정 데이터를 조회할 때 사용 

'쿼리스트링' : articles?page=1&keyword=react 
-> 주소의 뒷부분에 ? 문자열 이후 key=value로 값을 정의하며 
&연산자로 구분하는 형태로 이루어진다. 
키워드 검색 , 페이지네이션, 정렬방식등 데이터 조회에 필요한 옵션을 전달할때 

#useLocation 객체
   - pathname : 현재 주소의 경로(쿼리스트링 제외)
   - search: 맨앞의 ? 문자를 포함한 쿼리스트링 값
   - hash : 주소의 # 문자열 뒤의 값(주로 History API가 지원되지 않는 구형 브라우저에서 클라이언트 라우팅 사용할 때 쓰는 해시 라우터에서 사용한다.)
   - state : 페이지로 이동할 때 임의로 넣을 수 있는 상태 값
   - key : location 객체의 고유값, 초기에는 default이며 페이지가 변경될 때 마다 고유의 값이 생성됨.

?page=1&keyword=react 
이 문자열에서 앞에 있는 ?를 지우고 & 연산자로 분리한 뒤 key와 value를 파싱 하는 작업을 진행햐야 한다.
npm 에서 qs 또는 querystring 패키지를 설치해야 처리가능합니다. (리액트 v5 까지)
리액트에서는 'v6' 부터 'useSearchParams' 라는 hook을 통해서 쿼리스트링을 다룰수 있다. 


Outlet : Route의 children으로 들어가는 jsx 앨리먼트를 보여주는 역할을 한다.

<Route 'index' element={<Home />} />
//index 메인이라는 키워드 
index prop를 사용하면 상위 라우트의 경로와 일치하지만 그 이후에 경로가 주어지지 않았을 때 
보여지는 라우트를 설정할 수 있다. 
path='/'와 동일한 역할을 하고 이를 좀 더 명시적으로 표현하는 방법이다. 


'useNavigate' :  Link 컴포넌트를 사용하지 않고 다른 페이지로 이동해야 하는 상황에서 사용하는 Hook

# replace / Layout.js 참고 
navigate("/path", { replace: true });
페이지를 이동할 때 현재 페이지를 페이지 기록에 남기지 않는다.
articles로 이동했을때 그 이전 페이저가 기록에 남지 않는다. 

'NavLink' : 링크에서 사용하는 경로가 현재 라우트의 경로와 일치하는 경우 특정 스타일 또는 css클래스를 적용하는 컴포넌트이다.
<NavLink style={({isActive}) => (isActive ? activeStyle : undefined)} />

#MyPage.js 참고 
'Navigate' : 컴포넌트를 화면에 보여주는 순간 다른 페이지로 이동을 하고 싶을 떄 
페이지를 '리다이렉트'하고 싶을때 
예시로 인스타그램 치면 메인페이지로 들어가지않고 로그인 화면 이 나온다. 
즉 페이지를 우회 시킨다. 이때 페이지 리다이렉트 시킨다. 

지금까지는 라우터는 모든걸 다 읽히는데 그러면 안되고 
실제로 그 라우터 들어가서 읽혀야 하는데 
코드스프레이?때 다시 .. 성능 

https://newsapi.org/
api key 얻어오기 
f2631f791849422c9e22c328f8536f03



-------------------------------------------
function increase(number, callback){
  setTimeout(()=>{
    const result = number +10;
    if(callback){
      callback(result);
    }
  },1000)
}

console.log('작업 시작');
increase(0, result =>{
  console.log(result);
    increase(result, result =>{
      console.log(result);
          increase(result, result =>{
            console.log(result);
            increase(result, result =>{
            console.log(result);
              console.log('작업 완료');
        });
      });
  });
});

콜백안에 콜백안에 콜백...은
es6에서 'promise'로 사용한다.. 비동기
#es6 promise
function increase(number){
  ; resolve : 성공했을때 변수 + then이 받는다, reject : 실패 했을때 변수 + catch가 받는다.
  const promise = new Promise((resolve, reject)=>{
  setTimeout(()=>{
    const result = number +10;
    if(result > 50 ){
      const e = new Error('NumberTooBig');
      return reject(e);
    }
    resolve(result); 
  },1000);
});
  return promise;
}

increase(0).then(number =>{
  console.log(number);
  return increase(number);
})
.then(number =>{
  console.log(number);
  return increase(number);
})
.then(number =>{
  console.log(number);
  return increase(number);
})
.then(number =>{
  console.log(number);
  return increase(number);
})
.then(number =>{
  console.log(number);
  return increase(number);
})
.catch(e =>{
  console.log(e);
});


#async 비동기 
function increase(number){
  const promise = new Promise((resolve, reject)=>{
   
  setTimeout(()=>{
    const result = number +10;
    if(result > 50 ){
      const e = new Error('NumberTooBig');
      return reject(e);
    }
    resolve(result); 
  },1000);
});
  return promise;
}
#async 비동기 
async function runTasks(){
  try{
    let result = await increase(0);
    console.log(result);
    result = await increase(result);
    console.log(result);
    result = await increase(result);
    console.log(result);
    result = await increase(result);
    console.log(result);
    result = await increase(result);
    console.log(result);
    result = await increase(result);
    console.log(result);
  }catch (e){
    console.log(e);
  }
}

runTasks();