yarn start : git, node, yarn 설치가 제대로 되어야한다. 
인스타그램, 에어비앤비..리액트로 만듬 

리액트 는 라이브러리 (꼇다,켰다), 컴포넌트 , 페북에서 만듬  // 
뷰는 프레임워크 (자체 틀) - 개인이..만듬
리액트는 확장성 가능
자바스크립트 -> 리액트 -> 리액트네이티브 까지 가능 

기존 MVC 아키텍쳐의 단점을 보안
오직 뷰만 관리한다.!

초기렌더링 / 리렌더링 
리액트 : 수정된곳을 비교해서 바로 삭제 하고 바로 삽입 한다. (업데이트가 아니다)
기존 MVC 아키텍쳐  : 수정할곳을 찾아서 수정한다

리액트는 돔을 -> 버츄얼돔으로 사용한다.  

API 는 요청하고 주고 성호작용이 되어 // ex) 콘솔

돔 단점 : 동적 구조가 아님 / 정적 이다 
동적 구조 할려면 자바스크립트 사용 
웹브라우저에서 돔이 움직이면 여기에 대한 시간 소비가 큼.. 돔자체가 느린게 아님 

리액트에서 데이터가 변하면 웹브라우저에서 실제 DOM을 업데이트 할 때 3가지 절차가 있다.
1. 데이터를 업데이트 하면 전체 UI를 Virtual Dom에 리렌더링 한다.
2. 이전 Virtual Dom에 있던 내용과 현재 내용을 비교한다. (삭제후 삽입)
3. 바뀐 부분만 실제 Dom에 적용한다. 
초기렌더링을 복사한상태에서 리렌더링 비교 하면 된다. 다시 읽는 구조가 아님 

리액트 단점은 회사마다 플젝 다름
즉 규모가 작은거 필요가없다.

cli환경에서 이루어지는데 
cli환경 -> node 모듈이 무조건 깔아진다. 너무 무거우니까 작은규모에서 오히려 불필요 
상태관리, 최적화 관리

상태관리 : 클릭수 조회 

리덕트 까지 최종 목표 
자바스크립트에서 리덕스방법
리액트안에서 리덕스 방법


node js : 패키지를 쉽게 사용하기위해// 크롬 자바스크립트 엔진 런타임 // 웹브라우저에서 아닌곳에서 자바스크립트 사용하기 위해 // 주요 도구가 다 있다. 
패키지 관리 해주는 npm 
npm(노드 버전 맞춰야함..) 대신해서 사용가능한게 yarn (버전 상관없음) : (캐쉬 시스템, 부가서비스 기능 제공 npm 보다 요즘 좋다)


크로스브라우저들을 합쳤음 (각각 다르게 자바스크립트 문법이라 우리 이제 통합하자해서 es6 표준 했고.)
babel 사용해서 일반 자바스크립 코드를 변환해줘서 크로스브라우저에서 다 보여지도록 해준다. 


es5 이전 
var사용 하게 되면
this가 윈도우에 접하는 큰 단점이있어서
es6 이후에는 막았다.
let, const !

---jsx문법 --- 
index.js :  <React.StrictMode>  : 예전문법 사용 못하도록 16이상만 사용가능
but 2번씩 읽어 준다. 그래서 성능상 이슈 가 있어서 배포때 뺀다.

if 대신 조건부연산자로 사용한다 
0 : false
1: true

0은 false로 인식되니까 0으로 나온다. 
숫자값 0으로 처리하기위해서 따로 조건처리 해줘야한다. 

https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/undefined
-> mdn 공식 사이트 

리액트에서 undefined는 에러다. (기본 js랑 다름)
리액트 컴포넌트에서는 함수에서 undefined 만 반환하여 랜더링하면 안된다.
만약 undefined 꼭 필요한 상황이라면 ||(false인거니?) 연산자 사용하여 값을 지정해 오류를 방지할 수 있다. 
&&(참인거니?)

return <div></div> : jsx문법이다.. fragment, <>, <div> 3가지가 돔 구조 리액트 !


대응방법 
(o)
function myFunc() {
  const name = undefined;
  return name || "값이 undefined입니다 대응방법 "; --> o 
}
(o) jsx문법 활용 
function myFunc() {
  const name = undefined;
  return <div>{ name || "값이 undefined입니다 대응방법2" } </div> ; --> o 
}
(x)
function myFunc() {
  const name = undefined;
  return name; --> x 
}

.prettierrc 
https://prettier.io/docs/en/options.html


주석 길때는 /* */

class : 연관이 있는 집합을 연결해주는 함수의 집합

new {인스턴트} .. 
인스턴트 객체 : 복사한 객체..

prototype ES5 라서 class로 es6로 통합 되었당. 

리액트 v16.8 이후 함수형 컴포넌트 권장 !!
함수형 컴포넌트 단점은 state와 라이프사이클 api 사용이 불가능하다는 점인데 
이 단점은 리액트 v16.8 이후부터 Hooks 라는 기능이 도입이 되면서 해결되었다.
클래스형과 비슷하게 구현할 수 있다. 
리액트 공식 메뉴얼에서는 컴포넌트를 새로 작성 할 때는 함수 컴포넌트와 Hooks을 사용하도록 
권장 하고 있다. 그렇다고 클래스형 컴포넌트 사라진건 아니고 , 클래스형 컴포넌트 기능은
알아두는것을 권장 한다. 

일반함수 vs 화살표 함수 
this의 차이다. 
일반함수는 자신이 종속된 객체를 this로 가리킨다. 블럭으로 가리킨다.
화살표함수는 자신이 종속된 'new 인스턴스'로 가리킨다. 


//일반 함수의 this 
function BlackDog(){
  this.name = '흰둥이';
  return {
    name : '검둥이',
    bark : function(){
      console.log(this.name + ' : 멍멍');
    }
  }
}

const blackDog = new BlackDog();
blackDog.bark(); ---> 검둥이 : 멍멍 

//화살표 함수의 this 
function BlackDog(){
  this.name = '흰둥이';
  return {
    name : '검둥이',
    bark: ()=> {
      console.log(this.name + ' : 멍멍');
    }
  }
}

const blackDog = new BlackDog();
blackDog.bark(); ---> 흰둥이 : 멍멍 


#props(properties) 컴포넌트 속성을 설정할 때 사용하는 요소 
부모에 있는 prpos를 전달 받는거다.  

----------------------------------------------------07/09
gitbash = mac 호환 땜에 설치 
javascript 확장성 큰 이유는 node때문이기도 하다.

node : 태그 를 노드라고 한다. 그래서 텍스트토드 자식 노드 알아서 인식 한다. 

MDN 에서 찾아보자! 
https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment
destructuring : 구조 분해 할당
자바스크립트에서 자주 사용하는 문법 
var x = [1, 2, 3, 4, 5];
var [y, z] = x;
console.log(y); // 1
console.log(z); // 2

= 대입 / == 같다

자바스크립트 유연하지만 단점은 제약이 없다. 장점이자 단점
그래서 타입스크립트가 나왔다 


Class형태에서 proptypes 설정이 2가지 방법이 있다. 외부, 내부 
함수형은 proptypes 외부 설정만 있다.

유효성 검사 할때는 제약걸어야함 

state: 리액트에서 컴포넌트 내부에서 바뀔 수 있는 값. 변화를 주겠다. 
-> 변화가 이루어질 변수선언 키워드 . 
-> 변화가 이루어질려면 동작이 필요함 즉 함수가 필요하다. setState() 사용 

class state : state
function state : useStatea 라는 함수를 통해 사용한다. 

[[Prototype]] :  es6에서 클래스다 !

this.setState({ number: number + 1 })  ---> 초깃값에서 실행 
이전값 담고 실행하고싶을때 함수  
this.setState((prevState, props) => {
  number : prevState.number + 1
})
prevState : 기존 상태
props: 현재 지니고 있는 props를 가리킨다. 

callback 함수 : 함수에서 {}은 오브젝트말고 실행한다는 뜻, {}, ()=> 같이 쓴다면
()=>은 콜백 함수 라고 한다. 
함수 실행후 그 이후에 실행내용을 더 하는거다. 


// 구조화 
const array = [1,2];
const one = array[0];
const two = array[1];

//비구조화로 변경 후 *리액트에서 자주 사용한다 
const array = [1,2];
const [one, two] = array;


***리액트에서 함수 컴포넌트 hooks
hooks 
--> 클래스형에서 아주 잘 만들어놓은 함수를 함수 컴포넌트에서 hooks이라고 한다.
--> 배열에 비구조화 할당문으로 되어있다. 
--> 기본이 배열이다.
state 값을 바꾸어야 할 때는 setState 혹은 useStatea를 통해 전달받은 set 함수를 사용해야 한다. 

ex) state 사용법중 다음 코드는 잘못된 코드이다.
//클래스형 컴포넌트에서 (X)
공통 ) 기존에서 직접적으로 변경이 안됨 
this.state.number = this.state.number + 1;
this.state.array = this.array.push(2); //push 안됨
-> this.state.array = this.array.concat(2); // concat으로 사용 (ㅇ)
--> const id = [
  {id:1, value: true},
  {id:2, value: true},
  {id:3, value: false},
];
--> let idRest = id.concat({id:4, value : true});

-> const object = {a:1, b:2, c:3}; // (ㅇ)
--> const nextObj = {...object, b:4};  (ㅇ)
rest 연산자 라고도 불림 [...argumnet] : 복사해서 새로운 객체로 만듦 : https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Functions/arguments

this.state.object.value = 5; //직접적으로 지정 안됨 

//함수형 컴포넌트에서 (x)
const [object, setObject] = useStatea({a:1, b:2});
object.b = 3


===== 리액트 구조 특징 =====
(불변성) 이뮤터블 : 처음에 생선된 값은 변경되면 안된다는 규칙
-> 기존 있는걸 냅두고 , 새롭게 만든다. 그래서 변화감지가 있을때 
업데이트 하는게 아니라 삭제후 삽입이다. 

//생성, 수정, 삭제, 
const id = [
  {id:1, value: true},
  {id:2, value: true},
  {id:3, value: false},
];
//4를 추가
let idRest = id.concat({id:4, value : true});
//filter한다 (delete도 됨)
let idRest1 = idRest.filter(item => item.id !== 3);
//map 
let idRest2 = idRest1.map(item => (item.id === 1 ? {...item, value:false}: item));

#이벤트 핸들링
## 이벤트를 사용할때 주의사항
1. 이벤트 이름은 카멜 표기법으로 작성한다. 
2. 이벤트를 실행할 자바스크립트 코드를 전달하는 것이 아니라 함수형태의 값을 전달한다.
3. dom 요소에만 이벤트를 설정할 수 있다.
-> 우리가 직접 만든 컴포넌트에 이벤트를 자체적으로 설정할 수 없다. 
ex) <MyComopnent onClick ={doing}> 함수를 실행하는 것이 아니라.  그냥 이름이 onClick props 로 인식 되기때문이다. 
그러하여 <MyComopnent> 컴포넌트 안에 div즉 Dom 이벤트로 설정 해서 사용한다. 

##SyntheticBaseEvent : 값을 반환하고 초기화한다. 
즉 a를 한번 더 썻네가 아니라 초기화 후 aa 이네 
이렇게 !!! 생각 !!! 


#key [] 활용법 : 자바스크립트에서 있는 / 배열 아님 키값
const name = 'keyValue';
const object = {
  #key [] 감싸면 그 안에 레퍼런스가 가리키는 실제 값이 key값으로 사용된다. 
  [name]: 'value' // 
};
console.log(name) // 'keyValue' 

----------------------------------------------------07/16
ex) onKeyPress 함수 ===> onKeyUp
deprecated: (ㄷ프리케이트) 권장하지않는다 라는 뜻 / 실행은되지만 쓰지말라는 경고이다.
deprecated 문법이 보이면 찾아서 다른걸로 대체한다. 

excelh@naver.com => 강의쌤 이메일 

useState 성능적으로 안좋아서 훅으로 자주 사용한다
10개 useState 사용하는 정도 는 괜찮다. 

ref(래퍼런스 약어 참조): 선택자 바로 선택하겠금 해당 이름을 짓는다.   
id값 대신 사용하고, id는 전역이며 ref는 컴포넌트 내부 (지역변수)에서만 작동하기 때문에  
id 사용하는것보다 보안이 좋기때문에 
리액트에서는 id값보다 ref 많이 사용한다. 
<div ref=""></div>
 
#dom을 꼭 사용해야 하는 상황
1. 특정 엘리먼트에 (input) 포커스 추가
2. 스크롤 박스 조작하기 

## ref를 사용하는 방법 두 가지
1. 콜백함수를 통한 ref 설정 (콜백함수 함수안에 함수를 가지고 있는 객체 함수안 함수안 함수 )
<input ref={{내마음대로이름} => {this.내마음대로이름22=내마음대로이름}} /> // 'this.aaa = input'
ref={(refa) => (this.inputRef = refa)}
this.inputRef.focus(); 

2. createRef : 리액트16.3 이후부터 도입 
REF를 설정해준 dom에 접근하려면 this.input.current를 조회 하자. 
콜백함수와 다른점 : 뒷부분에 .current를 넣어 줘야한 다는 점 
this.inputRef.current.focus(); 

# 리액트에서 컴포넌트에도 ref를 달 수 있다. 이 방법은 주로 컴포넌트 내부에 있는 dom을 컴포넌트 외부에서 사용할때 쓴다.
# App_2.js 참고 
<Component ref={(ref) => {this.Component = ref}} />
이렇게 하면 Component에 내부의 메서드 및 멤버 변수에도 접근 할 수 있다. 
Component.input 엘리먼트접근가능
Component.handleClick 함수로 접근가능

## scroll: 안보이는 영역
-scrollTop : 세로 스크롤바 위치 (0-350) //650-300
-scrollHeight : 스크롤이 있는 박스 안의 div 높이 (650)
-clientHeight : 스크롤이 있는 박스의 높이 (300)

## map : key 무조건 있어야한다. index가 key가 아니다!! 중요!  그래서 index값을 키값으로 하면안된다. 
https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/map 
const numbers = [1,2,3,4,5,6,7];
const processed = numbers.map(function(num){
  return num + num;
});
const processed = numbers.map(num => num + num);
##index값을 키값으로 하면안된다. 
(X) : const nameList = names.map((name, idx) => <li key={idx}>{name}</li>)

##삭제 filter 
const nextNames = names.filter((name) => name.id !== id); //(5)번 id가 (5)번 id 빼고 나와라

##컴포넌트 반복 
유동적인 배열을 렌더링할 때는 고유한 key값을 설정해야 한다. 
배열을 변형할 때 배열에 직접 접근하여 수정하는게 아니라 
concat, filter 등의 배열 내장 함수를 사용 하여 새로운 배열을 만든 후 
새로운 상태로 설정해줘야 한다는 점 
<li key={name.id} onDoubleClick={() => onRemove(name.id)}>
  {name.text}
</li>

##hooks : 16.8 이후에 도입 리액트 내장함수 
1. useState(상태 관리의 가장 기본적인 hook)
하나의 상태값만 관리할 수 있다. 컴포넌트에서 관리해야 할 상태가 여러개라면 useState를 여러번 사용해야 한다. 
: 성능은 안좋다. 작은것에서 사용 한다. 10개 정도..
개선점을 배울것이다. 

2. useEffect : 기존 라이프사이클을 조작할수 있다. 
리액트 컴포넌트가 랜더링 될때마다 특정 작업을 수행하도록 설정할 수 있는 hook 입니다. 
클래스형 컴포넌트의 componentDidMount와 componentDidUpdate를 합친 형태로 봐도 무방 합니다. 

리액트 라이프사이클 (생명주기) 3단계
componentDidMount 시작, componentDidUpdate업데이트, componentWillUnmount제거 

## 2-1 시작할때와 업데이트 할때 처리 
useEffect(() => {
  console.log(`랜더링이 완료되었습니다`);
  console.log({
    name,
    nickname,
  });
});
## 2-2 시작할때만 처리  
useEffect(() => {
  console.log(`랜더링이 완료되었습니다`);
  console.log({
    name,
    nickname,
  });
}, []) ##비어있는 [] 추가: 업데이트할 처리 영역, 두번째 인자가 된다는 뜻이다. 

useEffect에서 설정한 함수를 컴포넌트가 화면에 맨 처음 랜더링될 때만 실행하고, 
업데이트 될때는 실행하지 않으려면 함수의 두번째 파라미터로 [] (비어있는 대괄호)를 주면된다. 
## 위 바탕으로 [] 가 성능을 좋게 만들수 있다. 

## 2-3 특정값만 업데이트 될 때만 실행 하고 싶을 떄 
## [] : 업데이트할 두변수를 비울거야 , [name] : name만 업데이트 할거야 ,  [nickname] : nickname만 업데이트 할거야 
useEffect(() => {
  console.log(`랜더링이 완료되었습니다`);
  console.log({
    name,
    nickname,
  });
}, [name]); //name만 업데이트 할거야
----------------------------------------------------07/23
componentDidUpdate : 업데이트!
componentDidUpdate(prevPrpos, prevState) {
  //이전값과하고 다르면 실행해라 업데이트
  if(prevProps.value !== this.props.vlaue) { 
    doSometing();
  }
}
위처럼 시작,업데이트할대마다 따로 써야해서 useEffect를 사용하는것이다.

useEffect : 랜더링이 되고나서 직후부터 시작한다. ,[]두번째에 따라 달라진다. 

#useEffect 뒷정리 함수 (Cleanup)
-컴포넌트가 언마운트(끝나기전) 전이나 '업데이트 되기 직전'에 어떠한 작업을 수행하고 싶다면 
useEffect에서 뒷정리함수를 반화해 줘야 한다. 
##뒷정리 함수 예시 : 장바구니에 담았고(업데이트) 바로 사이트를 닫게되면 닫기전에 나오는 '이창을 닫겠습니까?' 창이 나오는 부분
  useEffect(() => {
    console.log(`effect1`); //시작할때 출력 
    console.log(name); //업데이트 후 값
    return () => {
      console.log(`cleanup`); //언마운트 되기 전에 출력
      console.log(name); //업데이트 하기 전 값 출력
    };
  }, []);

## StrictMode 때문에 console -> effect1 cleanup effect :effect가 한번더 나오는 이유
https://ko.legacy.reactjs.org/docs/strict-mode.html
: 배포시 제외하기 

## useReducer : 리액트 함수 !  / 자바스크립트 reduce랑 비슷하다 
##info.js, Counter.js 참고 
'useReducer' : useState보다 더 '다양한 컴포넌트 상황'에 따라 '다양한 상태'를 다른값으로 업데이트 해줄때 사용

function reducer(state, action) {
  return{...} //불변성을 지키면서 업데이트한 새로운 상태를 반환한다.
}

'리듀서reducer'는 현재상태(초기값), 그리고 데이터 수정방법을 위해 필요한 정보를 담은 액션(action)
값을 전달받아 '새로운 상태를 반환하는 함수'(규칙은 새로운 상태를 만들때는 반드시 불변성을
지켜줘야 한다.)
https://www.w3schools.com/react/react_usereducer.asp
{
  type: 'INCREMENT', //다른 값들이 필요하다면 추가로 들어감 (액션이름)
}
useReducer의 첫번째 파라미터에는 리듀서 함수를 넣고 두번째 파라미터에는 해당 리듀서의 기본값을
넣어준다. 이 hook을 사용하면 state값과 dispatch 함수를 받아 오는데 여기서' state는 현재
가리키고 있는 상태'고, 'dispatch는 액션을 발생시키는 함수'이다. 
dispatch(action)과 같은 형태로, 함수 안에 파라미터로 액션값을 넣어주면 리듀서 함수가 호출되는 
구조이다. 
dispatch()를 사용하면 html안에서 reducer함수를 동작시킬수 있다. 

useState는 타입 하나만 지정할 수 있는 단점을' useReducer가 여러 타입을 지정 가능 '


#useMemo
함수 내부에서 발생하는 '연산을 최적화'할 수 있다. 
Average.js
렌더링하는 과정에서 특정 값이 바뀌었을때만 연산을 실행하고 원하는 값이 바뀌지 않았다면 
이전에 연산했던 결과를 사용하는 방식. 

숫자를 등록할 때 뿐만아니라 인풋 내용이 수정될때도 getAverage가 호출된다. (이부분이 문제)
인풋내용이 바뀔대는 평균값을 다시 계산할 필요가 없다. 
리스트 달라졌을때만 평균값을 계산해야한다. 
const avg = useMemo(() => getAverage(list), [list]);


#useCallback
Average.js
'렌더링 성능을 최적화'해야 하는 상황에서 사용 (함수 재사용)

#useRef(지역변수, DOM에 직접 접근할 수 있는 기능)
ref를 쉽게 사용할 수 있도록 해준다.
컴포넌트 안에서 


##hooks 모음 
https://nikgraf.github.io/react-hooks/